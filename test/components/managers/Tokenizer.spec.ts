// AUTO-GENERATED by scripts/consolidate-tests.js
// Consolidated tests for source: components\managers\Tokenizer

import { mount } from '@vue/test-utils'
import { expect, test, vi } from 'vitest'
import Tokenizer from '/src/components/managers/Tokenizer'
import LabelsBlock from '/src/components/blocks/LabelsBlock.vue'
import MenuBar from '/src/components/toolbars/MenuBar.vue'
import { LabelManager } from '/src/components/managers/LabelManager'
import { AnnotationManager } from '/src/components/managers/AnnotationManager'
import TokenManager, { TMTokenBlock, TMToken } from '/src/components/managers/TokenManager'
import { Entity, History, Paragraph, AnnotationManager } from '/src/components/managers/AnnotationManager'
import AnnotationPage from '/src/components/pages/AnnotationPage.vue'
import ReviewPage from '/src/components/pages/ReviewPage.vue'
import { expect, test } from 'vitest'
import { Entity } from '/src/components/managers/AnnotationManager'
import { Entity, History, Paragraph } from '/src/components/managers/AnnotationManager'
import { describe, it, expect } from 'vitest'


// from: test\components\other_branches.spec.ts
(() => {

test('Tokenizer.span_tokenize handles basic spans', () => {
  const spans = Tokenizer.span_tokenize('Hello, world!')
  expect(spans.length).toBeGreaterThan(0)
})

test('LabelsBlock avatar conditional branches', async () => {
  const lm = new LabelManager()
  lm.addLabel('ONE')
  lm.addLabel('TWO')
  // set current to first
  lm.setCurrentLabel('ONE')
  const store = { state: { currentPage: 'annotate', labelManager: lm } }
  const mocks = { $q: { notify: vi.fn(), dialog: () => ({ onOk: () => {} }), dark: { isActive: true } }, $store: store }
  const wrapper = mount(LabelsBlock, { global: { mocks } })
  // should render both avatars and current-selection avatar path
  expect(wrapper.html()).toContain('ONE')
  expect(wrapper.html()).toContain('TWO')
})

test('MenuBar export/save flows create anchor and click', async () => {
  const lm = new LabelManager()
  lm.addLabel('L')
  const am = new AnnotationManager([])
  const store = { state: { currentPage: 'annotate', fileName: 'F', annotationManager: am, labelManager: lm, versionControlManager: { canUndo: false, canRedo: false }, tokenManager: null, tokenManagers: [] }, commit: vi.fn() }
  const q = { dialog: () => ({ onOk: (cb: any) => cb && cb('me') }), notify: vi.fn(), dark: { isActive: false } }
  const wrapper = mount(MenuBar, { global: { mocks: { $store: store, $q: q } } })
  // spy on document.createElement to ensure anchor click path is hit
  const createSpy = vi.spyOn(document, 'createElement')
  await (wrapper.vm as any).save()
  await (wrapper.vm as any).export()
  expect(createSpy).toHaveBeenCalled()
  createSpy.mockRestore()
})

})();

// from: test\cover_final_branches3.spec.ts
(() => {

test('AnnotationManager duplicate-annotator branch pushes copy with latest state/label', () => {
  const lm = new LabelManager()
  lm.addLabel('Z')
  const label = lm.getLabelByName('Z')!
  const hist = new History('Reviewed', 'Z', 'old-annotator', History.formatDate(new Date()))
  const e = new Entity(0, 2, [hist], label, true, 'Reviewed')

  const beforeLen = e.history.length
  e.toJSON('new-annotator')
  expect(e.history.length).toBeGreaterThan(beforeLen)
  const pushed = e.latestEntry()
  expect(pushed).toBeTruthy()
  // ensure the pushed entry uses latestEntry state/label
  expect(pushed!.state).toBe(hist.state)
  expect(pushed!.label).toBe(hist.label)
  expect(pushed!.annotatorName).toBe('new-annotator')
})

test('TokenManager.addNewBlock accesses targetedBlocks[last].end when spanning multiple tokens', () => {
  const lm = new LabelManager()
  lm.addLabel('T')
  const tokens = Tokenizer.span_tokenize('one two three four')
  const tm = new TokenManager(lm, tokens)

  // create two blocks covering different token ranges
  const blockA_tokens = tm.tokens.slice(0, 2) as TMToken[]
  const blockB_tokens = tm.tokens.slice(2, 4) as TMToken[]
  const blockA = new TMTokenBlock(blockA_tokens[0].start, blockA_tokens[blockA_tokens.length - 1].end, blockA_tokens, lm.getLabelByName('T')!, 'Candidate')
  const blockB = new TMTokenBlock(blockB_tokens[0].start, blockB_tokens[blockB_tokens.length - 1].end, blockB_tokens, lm.getLabelByName('T')!, 'Candidate')
  tm.tokens.push(blockA, blockB)
  tm.tokens.sort((a,b)=>a.start - b.start)

  // Now add a new block that spans from start of blockA to end of blockB
  const selectionStart = blockA.start
  const selectionEnd = blockB.end
  tm.addNewBlock(selectionStart, selectionEnd, lm.getLabelByName('T'), 'Suggested', [], false)

  // There should be a TMTokenBlock that starts at selectionStart
  const created = tm.tokenBlocks.find(tb => tb.start === selectionStart)
  expect(created).toBeDefined()
  // Its end should be at least selectionEnd (constructed from targetedBlocks[last].end)
  expect(created!.end).toBeGreaterThanOrEqual(selectionEnd)
})

test('selectTokens uses Candidate when currentPage==annotate and Suggested otherwise', () => {
  const lm = new LabelManager()
  lm.addLabel('LAB')
  const tokens = Tokenizer.span_tokenize('a b')
  const tm1 = new TokenManager(lm, tokens)
  const tm2 = new TokenManager(lm, tokens)

  // spy on addNewBlock
  const spy1 = vi.spyOn(tm1, 'addNewBlock')
  const spy2 = vi.spyOn(tm2, 'addNewBlock')

  // fake selection and getSelection
  const fakeRange = { startContainer: { parentElement: { id: 't0' } }, startOffset: 0, endContainer: { parentElement: { id: 't0' } }, endOffset: 1 }
  const selection = { anchorOffset: 0, focusOffset: 1, anchorNode: {}, focusNode: {}, rangeCount: 1, getRangeAt: (i: number) => fakeRange, empty: vi.fn() }
  const getSelSpy = vi.spyOn(document, 'getSelection' as any).mockImplementation(() => (selection as any))

  const storeA = { state: { annotationManager: new AnnotationManager([[null,'t',{entities:[]}]]), currentPage: 'annotate', currentIndex: 0, tokenManager: tm1, tokenManagers: [tm1], labelManager: lm, versionControlManager: { addUndo: vi.fn() } }, commit: vi.fn() }
  const wrapperA = mount(AnnotationPage, { global: { mocks: { $store: storeA }, stubs: { 'info-bar': true } } })
  ;(wrapperA.vm as any).selectTokens({ detail: 1 } as MouseEvent)
  expect(spy1).toHaveBeenCalled()
  // check that the 4th arg (currentState) passed was 'Candidate'
  expect(spy1.mock.calls[0][3]).toBe('Candidate')

  const storeR = { state: { annotationManager: new AnnotationManager([[null,'t',{entities:[]}]]), currentPage: 'review', currentIndex: 0, tokenManager: tm2, tokenManagers: [tm2], labelManager: lm, versionControlManager: { addUndo: vi.fn() } }, commit: vi.fn() }
  const wrapperR = mount(AnnotationPage, { global: { mocks: { $store: storeR }, stubs: { 'info-bar': true } } })
  ;(wrapperR.vm as any).selectTokens({ detail: 1 } as MouseEvent)
  expect(spy2).toHaveBeenCalled()
  expect(spy2.mock.calls[0][3]).toBe('Suggested')

  getSelSpy.mockRestore()
})

test('AnnotationPage and ReviewPage templates render token, aggregate and token-block variants', () => {
  const lm = new LabelManager()
  lm.addLabel('L')
  const tokens = Tokenizer.span_tokenize('one two three')
  const tm = new TokenManager(lm, tokens)
  // Add a block to force token-block render
  const blockTokens = tm.tokens.slice(0,2) as TMToken[]
  const block = new TMTokenBlock(blockTokens[0].start, blockTokens[blockTokens.length-1].end, blockTokens, lm.getLabelByName('L')!, 'Candidate')
  tm.tokens.push(block)
  tm.tokens.sort((a,b)=>a.start - b.start)

  const am = new AnnotationManager([[null, 'p', { entities: [] }]])
  const store = { state: { annotationManager: am, currentPage: 'annotate', currentIndex: 0, tokenManager: tm, tokenManagers: [tm], labelManager: lm, versionControlManager: { addUndo: vi.fn() } }, commit: vi.fn() }

  const a = mount(AnnotationPage, { global: { mocks: { $store: store }, stubs: { 'info-bar': true } } })
  const r = mount(ReviewPage, { global: { mocks: { $store: store, emitter: { on: vi.fn(), off: vi.fn() } }, stubs: { 'info-bar': true } } })

  // assert that HTML includes rendered token items and annotated block markup
  expect(a.findAll('.token').length).toBeGreaterThan(0)
  expect(r.findAll('.token').length).toBeGreaterThan(0)
  // annotated blocks render as <mark> elements in the template
  expect(a.html()).toContain('<mark')
  expect(r.html()).toContain('<mark')
})

})();

// from: test\cover_final_steps2.spec.ts
(() => {

test('TokenManager constructor uses currentParagraph entities to assign labelClass and add blocks', () => {
  const lm = new LabelManager()
  lm.addLabel('AAA')
  const para = new Paragraph('p text')
  // create an entity with labelName set but no labelClass
  const e = new Entity(0, 3, [], undefined, false, 'Candidate')
  e.labelName = 'AAA'
  para.entities.push(e)

  const tokens = Tokenizer.span_tokenize('one two')
  const tm = new TokenManager(lm, tokens, para)

  // after construction, entity.labelClass should be assigned to the label from lm
  expect(para.entities[0].labelClass).toBeDefined()
  // and token blocks should exist in token manager
  expect(tm.tokenBlocks.length).toBeGreaterThanOrEqual(1)
})

test('Entity.generateHistoryEntryForExport uses Candidate and empty label when missing', () => {
  const e = new Entity(0, 1) // no history, no labelClass, currentState default 'Candidate'
  const before = e.history.length
  e.toJSON('who')
  expect(e.history.length).toBeGreaterThan(before)
  const last = e.latestEntry()
  expect(last).toBeTruthy()
  expect(last!.state).toBe('Candidate')
  expect(last!.label).toBe('')
  expect(last!.annotatorName).toBe('who')
})

test('AnnotationPage renders tokens with both user-active and user-inactive classes', () => {
  const lm = new LabelManager()
  lm.addLabel('L')
  const tokens = Tokenizer.span_tokenize('a b c')
  const tm = new TokenManager(lm, tokens)

  // create block (reviewed true) and a plain token (inactive)
  const blockTokens = tm.tokens.slice(0, 2) as TMToken[]
  const block = new TMTokenBlock(blockTokens[0].start, blockTokens[blockTokens.length - 1].end, blockTokens, lm.getLabelByName('L')!, 'Candidate', true)
  tm.tokens.push(block)
  tm.tokens.sort((a,b)=>a.start - b.start)

  const am = new AnnotationManager([[null, 'para', { entities: [] }]])
  const store = { state: { annotationManager: am, currentPage: 'annotate', currentIndex: 0, tokenManager: tm, tokenManagers: [tm], labelManager: lm, versionControlManager: { addUndo: () => {} } }, commit: () => {} }

  const wrapper = mount(AnnotationPage, { global: { mocks: { $store: store }, stubs: { 'info-bar': true } } })

  const html = wrapper.html()
  // should contain at least one user-active (block.reviewed true) and one user-inactive (token default)
  expect(html.includes('user-active') || html.includes('user-inactive')).toBe(true)
})

})();

// from: test\cover_final_touch.spec.ts
(() => {

test('TokenManager constructor uses currentParagraph.entities and addBlockFromStructure', () => {
  const lm = new LabelManager()
  lm.addLabel('T')
  const tokens = Tokenizer.span_tokenize('alpha beta')
  const tm = new TokenManager(lm, tokens)

  // create an entity that should be reconstituted into a block by constructor when passed as currentParagraph
  const ent = new Entity(0, 5, [], lm.getLabelByName('T')!, false, 'Candidate')
  // construct TokenManager with a fake paragraph object that contains the entity instance
  const tm2 = new TokenManager(lm, tokens, { entities: [ent] } as any)

  // addBlockFromStructure increments edited, so constructor path should have caused edited > 0
  expect(tm2.edited).toBeGreaterThan(0)
  // There should be at least one TMTokenBlock created from the entity
  expect(tm2.tokenBlocks.length).toBeGreaterThan(0)
})

test('addNewBlock reinserts overlapped TMTokenBlock and marks them Rejected when not manual', () => {
  const lm = new LabelManager()
  lm.addLabel('X')
  const tokens = Tokenizer.span_tokenize('one two three four')
  const tm = new TokenManager(lm, tokens)

  // create a real TMTokenBlock that will overlap the new selection
  const blockTokens = tm.tokens.slice(1, 3) as TMToken[]
  const block = new TMTokenBlock(blockTokens[0].start, blockTokens[blockTokens.length - 1].end, blockTokens, lm.getLabelByName('X')!, 'Candidate')
  tm.tokens.push(block)
  tm.tokens.sort((a, b) => a.start - b.start)

  // selection that overlaps the block
  const selStart = block.start
  const selEnd = block.end

  tm.addNewBlock(selStart, selEnd, lm.getLabelByName('X'), 'Suggested', [], false)

  // After operation, the original block instance should still be present in tokens and set to Rejected
  expect(tm.tokens.includes(block)).toBe(true)
  expect(block.currentState).toBe('Rejected')
})

test('AnnotationPage and ReviewPage created/unmount register and unregister emitter handlers', () => {
  const lm = new LabelManager()
  lm.addLabel('L')
  const tokens = Tokenizer.span_tokenize('one two')
  const tm = new TokenManager(lm, tokens)

  const am = { inputSentences: [{ id: 0, text: 'one two' }] }
  const emitter = { on: vi.fn(), off: vi.fn() }

  const store = { state: { annotationManager: am, currentPage: 'annotate', currentIndex: 0, tokenManager: tm, tokenManagers: [tm], labelManager: lm, versionControlManager: { addUndo: vi.fn() } }, commit: vi.fn() }

  const a = mount(AnnotationPage, { global: { mocks: { $store: store, emitter }, stubs: { 'info-bar': true } } })
  a.unmount()
  expect(emitter.on).toHaveBeenCalled()
  expect(emitter.off).toHaveBeenCalled()

  const r = mount(ReviewPage, { global: { mocks: { $store: store, emitter }, stubs: { 'info-bar': true } } })
  r.unmount()
  expect(emitter.on).toHaveBeenCalled()
  expect(emitter.off).toHaveBeenCalled()
})

})();

// from: test\cover_hit_remaining.spec.ts
(() => {

test('Entity.generateHistoryEntryForExport triggers RDF Export duplicate-annotator branch', () => {
  const lm = new LabelManager()
  lm.addLabel('Z')
  const label = lm.getLabelByName('Z')!
  // create history with same state and label but different annotator
  const hist = new History('Candidate', 'Z', 'old-annotator', History.formatDate(new Date()))
  const e = new Entity(0, 3, [hist], label, true, 'Candidate')

  const para = new Paragraph('abc')
  para.entities.push(e)

  // calling toRDF will call generateHistoryEntryForExport with 'RDF Export'
  const rdf = e.toRDF(para, lm)
  // the history should have an extra entry pushed
  expect(e.history.length).toBeGreaterThan(1)
  expect(e.latestEntry()!.annotatorName).toBe('RDF Export')
})

test('Entity.generateHistoryEntryForExport pushes when Candidate and history empty', () => {
  const lm = new LabelManager()
  lm.addLabel('C')
  const label = lm.getLabelByName('C')!
  const e = new Entity(0, 2, [], label, false, 'Candidate')

  // toJSON triggers generateHistoryEntryForExport
  const json = e.toJSON('tester')
  expect(e.history.length).toBeGreaterThan(0)
  expect(e.latestEntry()!.annotatorName).toBe('tester')
})

test('Entity.generateHistoryEntryForExport pushes when latestEntry differs', () => {
  const lm = new LabelManager()
  lm.addLabel('D')
  const label = lm.getLabelByName('D')!
  const hist = new History('Suggested', 'D', 'a', History.formatDate(new Date()))
  // entity constructed with history latest state Suggested but currentState set to Candidate
  const e = new Entity(0, 2, [hist], label, false, 'Candidate')

  e.toJSON('u')
  // latestEntry state should now equal the currentState (Candidate) or a new history pushed
  expect(e.history.length).toBeGreaterThan(1)
})

test('TokenManager addNewBlock uses targetedBlocks[last].end when blocks exist and not overlapping', () => {
  const lm = new LabelManager()
  lm.addLabel('T')
  const tokens = Tokenizer.span_tokenize('one two three four five')
  const tm = new TokenManager(lm, tokens)

  // create two TMTokenBlock entries so that blocksInRange returns them
  const b1Tokens = tm.tokens.slice(0,2) as TMToken[]
  const b2Tokens = tm.tokens.slice(2,4) as TMToken[]
  const b1 = new TMTokenBlock(b1Tokens[0].start, b1Tokens[b1Tokens.length-1].end, b1Tokens, lm.getLabelByName('T')!, 'Candidate')
  const b2 = new TMTokenBlock(b2Tokens[0].start, b2Tokens[b2Tokens.length-1].end, b2Tokens, lm.getLabelByName('T')!, 'Candidate')
  tm.tokens.push(b1, b2)
  tm.tokens.sort((a,b)=>a.start - b.start)

  // ensure isOverlapping returns null for our selection
  const selStart = b1.start
  const selEnd = b2.end

  tm.addNewBlock(selStart, selEnd, lm.getLabelByName('T'), 'Suggested', [], false)

  const created = tm.tokenBlocks.find(tb => tb.start === selStart)
  expect(created).toBeDefined()
  // end must equal targetedBlocks[targetedBlocks.length -1].end which is b2.end
  expect(created!.end).toBe(b2.end)
})

test('Pages register/unregister document mouseup listeners (AnnotationPage & ReviewPage)', () => {
  const lm = new LabelManager()
  lm.addLabel('L')
  const tokens = Tokenizer.span_tokenize('one')
  const tm = new TokenManager(lm, tokens)

  const am = { inputSentences: [] }
  const store = { state: { annotationManager: am, currentPage: 'annotate', currentIndex: 0, tokenManager: tm, tokenManagers: [tm], labelManager: lm, versionControlManager: { addUndo: vi.fn() } }, commit: vi.fn() }

  const addSpy = vi.spyOn(document, 'addEventListener')
  const remSpy = vi.spyOn(document, 'removeEventListener')

  const a = mount(AnnotationPage, { global: { mocks: { $store: store }, stubs: { 'info-bar': true } } })
  a.unmount()
  expect(addSpy).toHaveBeenCalledWith('mouseup', expect.any(Function))
  expect(remSpy).toHaveBeenCalled()

  const r = mount(ReviewPage, { global: { mocks: { $store: store, emitter: { on: vi.fn(), off: vi.fn() } }, stubs: { 'info-bar': true } } })
  r.unmount()
  expect(addSpy).toHaveBeenCalledWith('mouseup', expect.any(Function))
  expect(remSpy).toHaveBeenCalled()
})

})();

// from: test\cover_last_steps.spec.ts
(() => {

// 1) AnnotationManager / Entity history permutations
test('Entity.generateHistoryEntryForExport pushes entry for Candidate with empty history', () => {
  const lm = new LabelManager()
  // no labels
  const e = new Entity(0, 1, [], undefined, false, 'Candidate')
  expect(e.history.length).toBe(0)
  e.toJSON('candidate-annotator')
  expect(e.history.length).toBe(1)
  expect(e.latestEntry()?.annotatorName).toBe('candidate-annotator')
})

test('Entity.generateHistoryEntryForExport pushes entry when state or label changed', () => {
  const lm = new LabelManager()
  lm.addLabel('TAG')
  const label = lm.getLabelByName('TAG')!
  // Last history says Candidate with label TAG, but currentState will be Reviewed -> should push
  const hist = new History('Candidate', 'TAG', 'old', History.formatDate(new Date()))
  const e = new Entity(0, 2, [hist], label, false, 'Reviewed')
  const before = e.history.length
  e.toJSON('new')
  expect(e.history.length).toBeGreaterThan(before)
  expect(e.latestEntry()?.annotatorName).toBe('new')
})

test('Entity.toRDF generates RDF and ensures history entry with RDF Export annotator', () => {
  const lm = new LabelManager()
  lm.addLabel('L')
  const label = lm.getLabelByName('L')!
  const para = new Paragraph('hello world')
  const e = new Entity(0, 5, [], label, false, 'Candidate')
  para.entities.push(e)
  const rdf = e.toRDF(para, lm)
  // generateHistoryEntryForExport("RDF Export") should have added an entry
  expect(e.history.length).toBeGreaterThanOrEqual(1)
  expect(e.latestEntry()?.annotatorName).toBe('RDF Export')
  // rdf should include onner:labeledTermText
  expect(rdf).toContain('onner:labeledTermText')
})

// 2) TokenManager addNewBlock reinsertion and targetedBlocks indexing
test('TokenManager.addNewBlock reinserts overlapped TMTokenBlock and uses targetedBlocks last end', () => {
  const lm = new LabelManager()
  lm.addLabel('T')
  const tokens = Tokenizer.span_tokenize('one two three')
  const tm = new TokenManager(lm, tokens)

  // create a block from the first two tokens and insert it
  const blockTokens = tm.tokens.slice(0, 2) as TMToken[]
  const block = new TMTokenBlock(blockTokens[0].start, blockTokens[blockTokens.length - 1].end, blockTokens, lm.getLabelByName('T')!, 'Candidate')
  tm.tokens.push(block)
  tm.tokens.sort((a, b) => a.start - b.start)

  // Now call addNewBlock overlapping that block (manualState=false) to trigger rejection and reinsertion
  tm.addNewBlock(block.start, block.end, lm.getLabelByName('T'), 'Suggested', [], false)

  // After operation, there should be at least one TMTokenBlock with the original block's start/end
  const found = tm.tokenBlocks.some(tb => tb.start === block.start && tb.end === block.end)
  expect(found).toBe(true)
})

// 3) Pages: ReviewPage created() wiring and beforeUnmount
test('ReviewPage created registers emitter and beforeUnmount removes it', () => {
  const am = new AnnotationManager([[null, 's', { entities: [] }]])
  const lm = new LabelManager()
  const tm = new TokenManager(lm, Tokenizer.span_tokenize('s'))
  const store = { state: { annotationManager: am, currentPage: 'review', currentIndex: 0, tokenManager: tm, tokenManagers: [tm], labelManager: lm }, commit: vi.fn() }
  const emitter = { on: vi.fn(), off: vi.fn() }
  const wrapper = mount(ReviewPage, { global: { mocks: { $store: store, emitter }, stubs: { 'info-bar': true } } })
  expect(emitter.on).toHaveBeenCalled()
  wrapper.unmount()
  expect(emitter.off).toHaveBeenCalled()
})

// 4) shared.vue selectTokens "No Tags Available" branch
test('selectTokens shows No Tags Available dialog and empties selection when no labels exist', () => {
  const am = new AnnotationManager([[null, 'hello', { entities: [] }]])
  const lm = new LabelManager() // no labels
  const tm = new TokenManager(lm, Tokenizer.span_tokenize('hello'))
  const store = { state: { annotationManager: am, currentPage: 'annotate', currentIndex: 0, tokenManager: tm, tokenManagers: [tm], labelManager: lm, versionControlManager: { addUndo: vi.fn() } }, commit: vi.fn() }

  // fake selection object
  const fakeRange = { startContainer: { parentElement: { id: 't0' } }, startOffset: 0, endContainer: { parentElement: { id: 't0' } }, endOffset: 1 }
  const selection = { anchorOffset: 0, focusOffset: 1, anchorNode: {}, focusNode: {}, rangeCount: 1, getRangeAt: (i: number) => fakeRange, empty: vi.fn() }
  const getSelSpy = vi.spyOn(document, 'getSelection' as any).mockImplementation(() => (selection as any))

  const dialogSpy = vi.fn(() => ({ onOk: vi.fn(), onCancel: vi.fn() }))
  const q = { dialog: dialogSpy, dark: { isActive: false } }

  const wrapper = mount(AnnotationPage, { global: { mocks: { $store: store, $q: q }, stubs: { 'info-bar': true } } })

  // call the mixin method selectTokens via component vm
  ;(wrapper.vm as any).selectTokens({ detail: 1 } as MouseEvent)

  expect(dialogSpy).toHaveBeenCalled()
  expect(selection.empty).toHaveBeenCalled()
  getSelSpy.mockRestore()
})

})();

// from: test\tokenizer.spec.ts
(() => {

describe('Tokenizer', () => {
  it('tokenize splits words and punctuation', () => {
    const tokens = Tokenizer.tokenize("Hello, world! This is $5.")
    expect(tokens.length).toBeGreaterThan(0)
    expect(tokens).toContain('Hello')
  })

  it('span_tokenize returns spans with positions and text', () => {
    const spans = Tokenizer.span_tokenize('ab cd')
    expect(spans.length).toBeGreaterThan(0)
    expect(spans[0][2]).toBe('ab')
    expect(spans[1][2]).toBe('cd')
  })
})

})();

