// AUTO-GENERATED by scripts/consolidate-tests.js
// Consolidated tests for source: components\managers\VersionControlManager

import { describe, it, expect } from 'vitest'
import { VersionControlManager } from '/src/components/managers/VersionControlManager'
import { LabelManager } from '/src/components/managers/LabelManager'
import { TokenManager, TMTokenBlock, TMToken } from '/src/components/managers/TokenManager'
import { describe, it, expect, beforeEach } from 'vitest'
import { TokenManager, TMToken } from '/src/components/managers/TokenManager'
import { TokenManager, TMToken, TMTokenBlock } from '/src/components/managers/TokenManager'


// from: test\vcm_edges.spec.ts
(() => {
/* eslint-disable @typescript-eslint/no-explicit-any */

describe('VersionControlManager edge cases', () => {
  it('serialize/deserialize preserves unknown token shapes', () => {
    const vcm = new VersionControlManager()

    // fake tokenManager with an unknown token shape (no "type" property)
    const tm: any = { tokens: [{ start: 0, end: 1, currentState: 'X', extra: 'meta' }], edited: 0 }

    vcm.addUndo(tm)

    // mutate tokens to ensure restore happens
    tm.tokens = []

    vcm.undo(tm)

    // after undo, token should have been restored as plain object
    expect(tm.tokens.length).toBeGreaterThan(0)
    const restored = tm.tokens[0]
    expect(restored).toHaveProperty('extra', 'meta')
  })

  it('undoAll and redoAll iterate stacks correctly', () => {
    const vcm = new VersionControlManager()
    const tm: any = { tokens: [{ start: 0, end: 1, currentState: 'A' }], edited: 0 }

    // push multiple snapshots
    vcm.addUndo(tm)
    // mutate and push again
    tm.tokens[0].currentState = 'B'
    vcm.addUndo(tm)

    // ensure we have undo history
    expect(vcm.getUndoCount()).toBeGreaterThanOrEqual(2)

    // undoAll should move all to redo stack
    vcm.undoAll(tm)
    expect(vcm.getUndoCount()).toBe(0)
    expect(vcm.getRedoCount()).toBeGreaterThanOrEqual(1)

    // redoAll should restore back to most recent and empty redo
    vcm.redoAll(tm)
    expect(vcm.getRedoCount()).toBe(0)
    expect(vcm.getUndoCount()).toBeGreaterThanOrEqual(1)
  })
})

})();

// from: test\vcm_serialize.spec.ts
(() => {

// Create a token block helper
function makeBlock(start = 0) {
  const lm = new LabelManager()
  const tm = new TokenManager(lm, [[start, start + 1, 'a'], [start + 1, start + 2, 'b']])
  tm.addNewBlock(start, start + 2, lm.currentLabel, 'Candidate')
  return { tm, lm }
}

describe('VersionControlManager serialization branches', () => {
  it('serializeTokens handles token-block and token forms', () => {
    const { tm } = makeBlock(0)
    const vcm = new VersionControlManager()
    // addUndo should serialize token-block branch
    vcm.addUndo(tm)
    expect(vcm.getUndoCount()).toBeGreaterThan(0)
  })

  it('undo/redo will call deserializeTokens path for token-blocks', () => {
    const { tm } = makeBlock(10)
    const vcm = new VersionControlManager()
    vcm.addUndo(tm)
    // mutate tokens
    tm.tokens = []
    vcm.undo(tm)
    // after undo, tokens should have been restored
    expect(tm.tokens.length).toBeGreaterThan(0)
    vcm.redo(tm)
    expect(tm.tokens.length).toBeGreaterThanOrEqual(0)
  })
})

})();

// from: test\vcm_store_restore.spec.ts
(() => {
/* eslint-disable @typescript-eslint/no-explicit-any */

describe('VersionControlManager store restore branches', () => {
  let vcm: VersionControlManager
  beforeEach(() => {
    vcm = new VersionControlManager()
  })

  it('captures tokenManagers in snapshot and restores them on undo', () => {
    const lm = new LabelManager()
    const tm1 = new TokenManager(lm, [[0,1,'a']])
    const tm2 = new TokenManager(lm, [[1,2,'b']])

    // mutate some state
    tm1.tokens.push(new TMToken(2,3,'x','Candidate'))
    tm2.tokens.push(new TMToken(3,4,'y','Candidate'))

    // fake store with tokenManagers array
    const store: any = { state: { currentIndex: 1, tokenManagers: [tm1, tm2], tokenManager: tm1 }, commit: (name: string, payload: any) => { store.state.currentIndex = payload } }
    vcm.setStore(store)

    // Add undo which should capture tokenManagers
    vcm.addUndo(tm1)
    expect(vcm.getUndoCount()).toBeGreaterThanOrEqual(1)

    // Change active tokenManagers to empty to ensure restore does something
    tm1.tokens = []
    tm2.tokens = []

    vcm.undo(tm1)

    // After undo, the tokenManagers in store should have been restored
    expect(store.state.tokenManagers[0].tokens.length).toBeGreaterThan(0)
    expect(store.state.currentIndex).toBe(1)
  })

  it('trimStack respects maxStackSize and keeps recent snapshots', () => {
    vcm.setMaxStackSize(2)
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [])
    // Push multiple snapshots
    vcm.addUndo(tm)
    vcm.addUndo(tm)
    vcm.addUndo(tm)
    // Only last two should remain
    expect(vcm.getUndoCount()).toBeLessThanOrEqual(2)
  })
})

})();

// from: test\versionControl.spec.ts
(() => {

describe('VersionControlManager', () => {
  let vcm: VersionControlManager
  beforeEach(() => {
    vcm = new VersionControlManager()
  })

  it('can push and undo/redo simple token changes', () => {
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [])
    const token = new TMToken(0, 1, 'a', 'Candidate')
    tm.tokens.push(token)
    vcm.addUndo(tm)
    token.currentState = 'Accepted'
    vcm.undo(tm)
    expect((tm.tokens[0] as TMToken).currentState).toBe('Candidate')
    vcm.redo(tm)
    expect((tm.tokens[0] as TMToken).currentState).toBe('Accepted')
  })

  it('undo/redo stacks behave and counts update', () => {
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [])
    const t1 = new TMToken(0,1,'x','Candidate')
    tm.tokens.push(t1)
    expect(vcm.getUndoCount()).toBe(0)
    vcm.addUndo(tm)
    expect(vcm.getUndoCount()).toBe(1)
    vcm.undo(tm)
    expect(vcm.getRedoCount()).toBe(1)
  })
})

})();

// from: test\versionControl_more.spec.ts
(() => {

describe('VersionControlManager extended', () => {
  it('setMaxStackSize trims undo/redo stacks', () => {
    const vcm = new VersionControlManager()
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [])
    // push several snapshots
    for (let i = 0; i < 10; i++) {
      tm.edited = i
      vcm.addUndo(tm)
    }
    expect(vcm.getUndoCount()).toBe(10)
    vcm.setMaxStackSize(5)
    expect(vcm.getUndoCount()).toBeLessThanOrEqual(5)
  })

  it('clearHistory clears stacks and undo/redo disabled', () => {
    const vcm = new VersionControlManager()
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [])
    vcm.addUndo(tm)
    expect(vcm.canUndo).toBe(true)
    vcm.clearHistory()
    expect(vcm.canUndo).toBe(false)
    expect(vcm.canRedo).toBe(false)
  })
})

})();

