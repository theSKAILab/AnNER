// AUTO-GENERATED by scripts/consolidate-tests.js
// Consolidated tests for source: components\managers\TokenManager

import { expect, test } from 'vitest'
import { TokenManager, TMToken, TMTokenBlock, TMTokenAggregate } from '/src/components/managers/TokenManager'
import { LabelManager } from '/src/components/managers/LabelManager'
import { Paragraph, Entity } from '/src/components/managers/AnnotationManager'
import { expect, test, vi } from 'vitest'
import TokenManager, { TMToken, TMTokenBlock } from '/src/components/managers/TokenManager'
import { Label, LabelManager } from '/src/components/managers/LabelManager'
import { describe, it, expect } from 'vitest'
import { TokenManager, TMTokenBlock, TMToken } from '/src/components/managers/TokenManager'
import { TokenManager } from '/src/components/managers/TokenManager'
import { TokenManager, TMToken, TMTokenBlock } from '/src/components/managers/TokenManager'
import { Entity, Paragraph } from '/src/components/managers/AnnotationManager'


// from: test\managers\tokenmanager_additional.spec.ts
(() => {

test('TokenManager addNewBlock overlapping reinserts and dedupe branches', () => {
  const lm = new LabelManager()
  lm.addLabel('A')
  const tokens = [[0,1,'a'],[1,2,'b'],[2,3,'c']] as any
  const tm = new TokenManager(lm, tokens)
  // create a block from structure
  const e = new Entity(0,2,[], lm.currentLabel, false, 'Candidate')
  tm.addBlockFromStructure(e)
  // now add overlapping block that should trigger overlappedBlocks path
  tm.addNewBlock(1,3, lm.currentLabel, 'Suggested')
  expect(tm.tokens.length).toBeGreaterThan(0)
})

test('TokenManager removeBlock reintroduceTokens true/false and restoreOriginalBlockState', () => {
  const lm = new LabelManager()
  lm.addLabel('B')
  const tokens = [[0,1,'x'],[1,2,'y']] as any
  const tm = new TokenManager(lm, tokens)
  const e = new Entity(0,2,[], lm.currentLabel, false, 'Candidate')
  tm.addBlockFromStructure(e)
  const start = tm.tokenBlocks[0].start
  tm.removeBlock(start, false)
  const lenAfterNoReintro = tm.tokens.length
  // tokens were removed and not reintroduced; recreate TokenManager to test reintroduce true path
  const tm2 = new TokenManager(lm, tokens)
  tm2.addBlockFromStructure(e)
  const start2 = tm2.tokenBlocks[0].start
  tm2.removeBlock(start2, true)
  expect(tm2.tokens.length).toBeGreaterThanOrEqual(lenAfterNoReintro)
  // restore original state
  tm.restoreOriginalBlockState(start)
  expect(tm.edited).toBeGreaterThanOrEqual(1)
})

})();

// from: test\managers\tokenmanager_branches.spec.ts
(() => {

test('addNewBlock handles overlapping blocks and reinserts', () => {
  const label = new Label(1, 'X', 'red-11')
  const lm = new LabelManager([label])
  const spans = [[0,1,'a'], [1,2,'b'], [2,3,'c']]
  const tm = new TokenManager(lm, spans as any)

  // create an existing block that overlaps
  const existingBlock = new TMTokenBlock(0,2, [TMToken.fromObject([0,1,'a']), TMToken.fromObject([1,2,'b'])], label, 'Candidate')
  tm.tokens.push(existingBlock)

  // now add a new block overlapping the same range
  tm.addNewBlock(0,2,label,'Suggested')

  // should have at least one TMTokenBlock now
  expect(tm.tokenBlocks.length).toBeGreaterThanOrEqual(1)
})

test('removeBlock reintroduceTokens true and false increments edited', () => {
  const label = new Label(1, 'Y', 'blue-11')
  const lm = new LabelManager([label])
  const spans = [[0,1,'a'], [1,2,'b']]
  const tm = new TokenManager(lm, spans as any)

  const block = new TMTokenBlock(0,2, [TMToken.fromObject([0,1,'a']), TMToken.fromObject([1,2,'b'])], label, 'Candidate')
  tm.tokens.push(block)

  const before = tm.edited
  tm.removeBlock(0, true)
  expect(tm.edited).toBeGreaterThanOrEqual(before + 1)

  // add again
  tm.tokens.push(block)
  const before2 = tm.edited
  tm.removeBlock(0, false)
  expect(tm.edited).toBeGreaterThanOrEqual(before2 + 1)
})

test('restoreOriginalBlockState increments edited when block exists', () => {
  const label = new Label(1, 'Z', 'green-11')
  const lm = new LabelManager([label])
  const spans = [[0,1,'a']]
  const tm = new TokenManager(lm, spans as any)

  const block = new TMTokenBlock(0,1, [TMToken.fromObject([0,1,'a'])], label, 'Candidate')
  block.currentState = 'Modified'
  tm.tokens.push(block)

  const before = tm.edited
  tm.restoreOriginalBlockState(0)
  expect(tm.edited).toBeGreaterThanOrEqual(before + 1)
  expect(block.currentState).toBe('Candidate')
})

describe('TokenManager remaining branches', () => {
  it('addNewBlock overlapping path and removeBlock reintroduce false', () => {
    const lm = new LabelManager()
    lm.addLabel('X')
    const tm = new TokenManager(lm, [[0,1,'a'], [1,2,'b'], [2,3,'c']])
    // create a block that will overlap
    tm.addNewBlock(0,2, lm.currentLabel, 'Accepted')
    // now add another overlapping block that triggers reinsert logic
    tm.addNewBlock(1,3, lm.currentLabel, 'Accepted')
    expect(tm.tokenBlocks.length).toBeGreaterThan(0)

    // removeBlock without reintroduce
    const start = tm.tokenBlocks[0].start
    tm.removeBlock(start, false)
    // ensure tokens no longer include that block start
    expect(tm.getBlockByStart(start)).toBeNull()
  })

  it('restoreOriginalBlockState increments edited when found', () => {
    const lm = new LabelManager()
    lm.addLabel('A')
    const tm = new TokenManager(lm, [[0,1,'a']])
    const b = new TMTokenBlock(0,1,[new TMToken(0,1,'a','Candidate')], lm.currentLabel as any, 'Candidate')
    tm.tokens.push(b)
    const before = tm.edited
    tm.restoreOriginalBlockState(0)
    expect(tm.edited).toBeGreaterThanOrEqual(before + 1)
  })
})

})();

// from: test\more_tokens.spec.ts
(() => {

describe('TokenManager additional behaviors', () => {
  it('addNewBlock handles overlapping blocks and removeDuplicateBlocks', () => {
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [[0,1,'a'], [2,3,'b'], [4,5,'c']])
    // create initial block covering 2..3
    tm.addNewBlock(2,3, lm.currentLabel, 'Candidate')
    expect(tm.tokenBlocks.length).toBeGreaterThan(0)
    // add another block that overlaps existing block and tokens
    tm.addNewBlock(1,4, lm.currentLabel, 'Accepted')
    // Ensure tokens array stays sorted and duplicates removed
    tm.removeDuplicateBlocks()
    expect(tm.tokens.length).toBeGreaterThan(0)
  })

  it('getBlockByStart returns null for missing block and restoreOriginalBlockState is safe', () => {
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [[0,1,'a']])
    expect(tm.getBlockByStart(999)).toBeNull()
    // calling restoreOriginalBlockState on non-existing start should not throw
    tm.restoreOriginalBlockState(999)
  })
})

})();

// from: test\tokenManager.spec.ts
(() => {

describe('TokenManager', () => {
  it('blocksInRange and getBlockByStart work and add/remove block', () => {
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [[0,1,'a'], [2,3,'b']])
    expect(tm.blocksInRange(0,3).length).toBeGreaterThan(0)
    tm.addNewBlock(0,3, undefined, 'Candidate')
    expect(tm.tokenBlocks.length).toBeGreaterThan(0)
    const start = tm.tokenBlocks[0].start
    expect(tm.getBlockByStart(start)).not.toBeNull()
    tm.removeBlock(start)
    expect(tm.getBlockByStart(start)).toBeNull()
  })

  it('isOverlapping detects overlaps and restoreOriginalBlockState restores', () => {
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [[0,1,'a'], [1,2,'b'], [3,4,'c']])
    tm.addNewBlock(0,2, undefined, 'Candidate')
    const overlaps = tm.isOverlapping(0,2)
    expect(overlaps).not.toBeNull()
    const block = tm.tokenBlocks[0]
    block.labelClass = lm.currentLabel as any
    block.currentState = 'Accepted'
    tm.restoreOriginalBlockState(block.start)
    // after restore, reviewed toggles but function should complete
    expect(tm.getBlockByStart(block.start)).not.toBeNull()
  })
})

})();

// from: test\tokenManager_edge.spec.ts
(() => {
/* eslint-disable @typescript-eslint/no-explicit-any */

describe('TokenManager edge cases', () => {
  it('addBlockFromStructure inserts block and increments edited', () => {
    const lm = new LabelManager()
    lm.addLabel('A')
    const tokens = [[0,1,'a'], [1,2,'b']] as any
    const tm = new TokenManager(lm, tokens)

    const block = new TMTokenBlock(0, 2, [new TMToken(0,1,'a','Candidate'), new TMToken(1,2,'b','Candidate')], lm.getLabelByName('A') as any, 'Candidate')
    const before = tm.edited
    tm.addBlockFromStructure(block)
    expect(tm.getBlockByStart(0)).not.toBeNull()
    expect(tm.edited).toBe(before + 1)
  })

  it('removeBlock with reintroduceTokens=false does not reinsert tokens', () => {
    const lm = new LabelManager()
    lm.addLabel('B')
    const tokens = [[0,1,'x'], [1,2,'y']] as any
    const tm = new TokenManager(lm, tokens)

    // add block normally
    tm.addNewBlock(0,2, lm.getLabelByName('B'), 'Candidate', [])
    const beforeTokens = tm.tokens.length
    tm.removeBlock(0, false)
    // after removal without reintroduceTokens, tokens should be smaller or equal
    expect(tm.tokens.length).toBeLessThanOrEqual(beforeTokens)
    // block should no longer exist
    expect(tm.getBlockByStart(0)).toBeNull()
  })

  it('removeDuplicateBlocks deduplicates token blocks', () => {
    const lm = new LabelManager()
    lm.addLabel('C')
    const tokens = [[0,1,'a'], [1,2,'b']] as any
    const tm = new TokenManager(lm, tokens)
    tm.addNewBlock(0,2, lm.getLabelByName('C'), 'Candidate', [])
    // artificially duplicate
    const blk = tm.getBlockByStart(0)
    if (blk) tm.tokens.push(blk)
    const before = tm.tokens.length
    tm.removeDuplicateBlocks()
    expect(tm.tokens.length).toBeLessThan(before)
  })

  it('restoreOriginalBlockState is safe when block exists', () => {
    const lm = new LabelManager()
    lm.addLabel('D')
    const tokens = [[0,1,'a'], [1,2,'b']] as any
    const tm = new TokenManager(lm, tokens)
    tm.addNewBlock(0,2, lm.getLabelByName('D'), 'Candidate', [])
    const blk = tm.getBlockByStart(0)
    expect(() => { if (blk) { blk.currentState = 'Modified'; tm.restoreOriginalBlockState(0) } }).not.toThrow()
  })
})

})();

// from: test\tokenManager_more_branches.spec.ts
(() => {

describe('TokenManager advanced branches', () => {
  it('addBlockFromStructure inserts block and increments edited', () => {
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [[0,1,'a'], [1,2,'b']])
    const beforeEdited = tm.edited

    // Test addBlockFromStructure increments edited and inserts block
  // create a block that overlaps existing tokens (0..2) so targetedBlocks is not empty
  const block = new TMTokenBlock(0, 2, [new TMToken(0,1,'a','Candidate'), new TMToken(1,2,'b','Candidate')], lm.currentLabel as unknown as any, 'Candidate')
    tm.addBlockFromStructure(block)
    expect(tm.edited).toBeGreaterThan(beforeEdited)
    expect(tm.getBlockByStart(block.start)).not.toBeNull()
  })

  it('removeDuplicateBlocks deduplicates tokens', () => {
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [[0,1,'a'], [1,2,'b']])
    // add duplicate blocks by reference
    const b = new TMTokenBlock(0, 2, [new TMToken(0,1,'a','Candidate')], lm.currentLabel as any, 'Candidate')
    tm.tokens.push(b)
    tm.tokens.push(b)
    tm.removeDuplicateBlocks()
  // tokens should be deduplicated (edited should increment)
  const before = tm.edited
  tm.removeDuplicateBlocks()
  expect(tm.edited).toBeGreaterThanOrEqual(before + 1)
  })

  it('addNewBlock manualState path toggles manual behavior', () => {
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [[0,1,'a'], [2,3,'b'], [4,5,'c']])
    // create an overlapping scenario
    tm.addNewBlock(0,2, lm.currentLabel as any, 'Candidate')
    const existing = tm.isOverlapping(0,2)
    expect(existing).not.toBeNull()
    // call addNewBlock with manualState true to trigger different path
    tm.addNewBlock(0,1, lm.currentLabel as any, 'Candidate', [], true)
    // ensure tokens array remains sorted and valid
    expect(Array.isArray(tm.tokens)).toBe(true)
  })
})

})();

