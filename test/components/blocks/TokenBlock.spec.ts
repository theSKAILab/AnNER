// AUTO-GENERATED by scripts/consolidate-tests.js
// Consolidated tests for source: components\blocks\TokenBlock

import { shallowMount } from '@vue/test-utils'
import TokenBlock from '/src/components/blocks/TokenBlock.vue'
import { test, expect, vi, afterEach } from 'vitest'
import { TMToken } from '/src/components/managers/TokenManager'
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'


// from: test\components\TokenBlock.spec.ts
(() => {

describe('TokenBlock', () => {
  function makeToken() {
    return {
      start: 0,
      tokens: [{ start: 0, text: 'hello' }],
      labelClass: { id: 1, name: 'A', color: 'red-11' },
      currentState: 'Candidate',
      reviewed: false,
    }
  }

  it('cycleCurrentStatus advances state and marks reviewed', async () => {
    const tokenManager = { /* methods used by VCM */ }
    const vcm = { addUndo: vi.fn() }
    const labelManager = { currentLabel: { id: 99, name: 'NEW', color: 'blue-11' } }

    const wrapper = shallowMount(TokenBlock, {
      props: { token: makeToken() },
      global: {
        mocks: { $store: { state: { currentPage: 'review', versionControlManager: vcm, tokenManager: {}, labelManager } } },
        provide: {},
      },
    })

    // attach managers directly to vm as mappedState uses $store.state normally
    ;(wrapper.vm as any).versionControlManager = vcm
    ;(wrapper.vm as any).tokenManager = tokenManager

    await (wrapper.vm as any).cycleCurrentStatus()
    expect(vcm.addUndo).toHaveBeenCalled()
    expect((wrapper.props() as any).token.currentState).not.toBe('Candidate')
    expect((wrapper.props() as any).token.reviewed).toBe(true)
  })

  it('changeLabel sets suggested state when currentPage is review and updates label', async () => {
    const token = makeToken()
    const vcm = { addUndo: vi.fn() }
    const labelManager = { currentLabel: { id: 5, name: 'B', color: 'green-11' } }

    const wrapper = shallowMount(TokenBlock, {
      props: { token },
      global: { mocks: { $store: { state: { currentPage: 'review', versionControlManager: vcm, tokenManager: {}, labelManager } } } },
    })

    // attach versionControlManager on the vm as well to be safe for direct access
    ;(wrapper.vm as any).versionControlManager = vcm
    await (wrapper.vm as any).changeLabel()
    expect(vcm.addUndo).toHaveBeenCalled()
    expect(token.reviewed).toBe(true)
    expect(token.currentState).toBe('Suggested')
    expect(token.labelClass).toBe(labelManager.currentLabel)
  })

  it('removeBlock emits remove-block when not on review page', async () => {
    const token = makeToken()
    const wrapper = shallowMount(TokenBlock, {
      props: { token },
      global: { mocks: { $store: { state: { currentPage: 'annotate' } } } },
    })

    await (wrapper.vm as any).removeBlock()
    expect(wrapper.emitted()).toHaveProperty('remove-block')
  })

  it('removeBlock marks rejected and adds undo on review page', async () => {
    const token = makeToken()
    const vcm = { addUndo: vi.fn() }
    const wrapper = shallowMount(TokenBlock, {
      props: { token },
      global: { mocks: { $store: { state: { currentPage: 'review', versionControlManager: vcm, tokenManager: { restoreOriginalBlockState: vi.fn() } } } } },
    })

    await (wrapper.vm as any).removeBlock()
    expect(vcm.addUndo).toHaveBeenCalled()
    expect(token.currentState).toBe('Rejected')
    expect(token.reviewed).toBe(true)
  })

  it('toggleReviewed restores original when token.reviewed is true', async () => {
    const token = makeToken()
    token.reviewed = true
    const tokenManager = { restoreOriginalBlockState: vi.fn() }
    const wrapper = shallowMount(TokenBlock, {
      props: { token },
      global: { mocks: { $store: { state: { currentPage: 'review', tokenManager } } } },
    })
    await (wrapper.vm as any).toggleReviewed()
    expect(tokenManager.restoreOriginalBlockState).toHaveBeenCalledWith(token.start)
  })
})

afterEach(() => vi.restoreAllMocks())

test('cycleCurrentStatus, changeLabel, removeBlock and toggleReviewed behavior', () => {
  const token = new TMToken(0,1,'t','Candidate')
  token.currentState = 'Candidate'
  token.labelClass = { id:1, name:'L', color:'red-11' }

  const tokenManager = { restoreOriginalBlockState: vi.fn() }
  const versionControlManager = { addUndo: vi.fn() }
  const labelManager = { currentLabel: { id:2, name:'NEW', color:'blue-11' } }

  const store: any = { state: { currentPage: 'review', tokenManager, versionControlManager, labelManager } }
  const vm = shallowMount(TokenBlock, { props: { token }, global: { mocks: { $store: store } } })

  // cycleCurrentStatus should call addUndo and update state/reviewed
  ;(vm.vm as any).cycleCurrentStatus()
  expect(versionControlManager.addUndo).toHaveBeenCalledWith(tokenManager)
  expect(token.currentState).not.toBe('Candidate')
  expect(token.reviewed).toBe(true)

  // changeLabel should set reviewed and labelClass
  token.currentState = 'Candidate'
  ;(vm.vm as any).changeLabel()
  expect(versionControlManager.addUndo).toHaveBeenCalled()
  expect(token.labelClass).toEqual(labelManager.currentLabel)

  // removeBlock in review mode should call addUndo and set Rejected
  token.currentState = 'Candidate'
  token.reviewed = false
  ;(vm.vm as any).removeBlock()
  expect(versionControlManager.addUndo).toHaveBeenCalled()
  expect(token.currentState).toBe('Rejected')

  // toggleReviewed when reviewed true should call restoreOriginalBlockState
  token.reviewed = true
  ;(vm.vm as any).toggleReviewed()
  expect(tokenManager.restoreOriginalBlockState).toHaveBeenCalledWith(token.start)
})
/* eslint-disable @typescript-eslint/no-explicit-any */

// Minimal mocks for store-mapped values
const label = { id: 1, name: 'TEST', color: 'red11' }
const token = {
  type: 'block',
  start: 0,
  tokens: [{ type: 'token', start: 0, text: 'hello' }],
  labelClass: label,
  currentState: 'Candidate',
  reviewed: false,
}

const versionControlManager = { addUndo: vi.fn() }
const tokenManager = { restoreOriginalBlockState: vi.fn() }
const labelManager = { currentLabel: label }

const mockStore = {
  state: {
    currentPage: 'review',
    versionControlManager: versionControlManager,
    tokenManager: tokenManager,
    labelManager: labelManager,
  },
}

describe('TokenBlock component', () => {
  it('cycles status and sets reviewed', async () => {
    const wrapper = mount(TokenBlock as unknown as Record<string, unknown>, {
      props: { token },
      global: {
        mocks: { $store: mockStore, $q: { dark: { isActive: false } }, versionControlManager: versionControlManager, tokenManager: tokenManager, labelManager: labelManager },
        stubs: { 'q-btn': true },
      },
    })
    // call methods directly
    // call the method on the component instance
  ;(wrapper.vm as any).cycleCurrentStatus()
    expect(token.reviewed).toBe(true)
  })

  it('changeLabel sets labelClass and marks reviewed', async () => {
    const localToken = { ...token, labelClass: { id: 2, name: 'OLD', color: 'blue11' } }
    const vcm = { addUndo: vi.fn() }
    const tm = { restoreOriginalBlockState: vi.fn() }
    const lm = { currentLabel: { id: 3, name: 'NEW', color: 'green11' } }

    const wrapper = mount(TokenBlock as any, {
      props: { token: localToken },
      global: { mocks: { $store: { state: { currentPage: 'review', versionControlManager: vcm, tokenManager: tm, labelManager: lm } }, versionControlManager: vcm, tokenManager: tm, labelManager: lm }, stubs: { 'q-btn': true } },
    })

    ;(wrapper.vm as any).changeLabel()
    expect(localToken.reviewed).toBe(true)
    expect(localToken.labelClass).toBe(lm.currentLabel)
  })

  it('removeBlock emits remove-block when not in review', async () => {
    const localToken = { ...token }
    const wrapper = mount(TokenBlock as any, {
      props: { token: localToken },
      global: { mocks: { $store: { state: { currentPage: 'annotate', versionControlManager: { addUndo: vi.fn() }, tokenManager: {} } } }, stubs: { 'q-btn': true } },
    })

    ;(wrapper.vm as any).removeBlock()
    // should have emitted remove-block
    expect(wrapper.emitted()['remove-block']).toBeTruthy()
  })

  it('toggleReviewed restores original state when reviewed true', async () => {
    const localToken = { ...token, reviewed: true }
    const tm = { restoreOriginalBlockState: vi.fn() }
    const wrapper = mount(TokenBlock as any, {
      props: { token: localToken },
      global: { mocks: { $store: { state: { currentPage: 'review', tokenManager: tm } }, tokenManager: tm }, stubs: { 'q-btn': true } },
    })

    ;(wrapper.vm as any).toggleReviewed()
    expect(tm.restoreOriginalBlockState).toHaveBeenCalledWith(localToken.start)
  })

  it('removeBlock calls addUndo and marks rejected when in review', async () => {
    const localToken = { ...token, currentState: 'Candidate', reviewed: false }
    const vcm = { addUndo: vi.fn() }
    const tm = { restoreOriginalBlockState: vi.fn() }

    const wrapper = mount(TokenBlock as any, {
      props: { token: localToken },
      global: {
        mocks: { $store: { state: { currentPage: 'review', versionControlManager: vcm, tokenManager: tm, labelManager: labelManager } }, versionControlManager: vcm, tokenManager: tm, labelManager: labelManager },
        stubs: { 'q-btn': true },
      },
    })

    ;(wrapper.vm as any).removeBlock()
    expect(vcm.addUndo).toHaveBeenCalled()
    expect(localToken.currentState).toBe('Rejected')
    expect(localToken.reviewed).toBe(true)
  })

  it('toggleReviewed sets reviewed when initially false', async () => {
    const localToken = { ...token, reviewed: false }
    const tm = { restoreOriginalBlockState: vi.fn() }
    const wrapper = mount(TokenBlock as any, {
      props: { token: localToken },
      global: { mocks: { $store: { state: { currentPage: 'review', tokenManager: tm } }, tokenManager: tm }, stubs: { 'q-btn': true } },
    })

    ;(wrapper.vm as any).toggleReviewed()
    expect(localToken.reviewed).toBe(true)
    expect(tm.restoreOriginalBlockState).not.toHaveBeenCalled()
  })
})


})();

