// AUTO-GENERATED by scripts/consolidate-tests.js
// Consolidated tests for source: components\pages\shared

import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import Shared from '/src/components/pages/shared.vue'
import { describe, it, expect, vi } from 'vitest'
import { expect, test } from 'vitest'
import { TMTokenBlock, TMToken, TMTokenAggregate } from '/src/components/managers/TokenManager'
import { Label } from '/src/components/managers/LabelManager'
import { LabelManager } from '/src/components/managers/LabelManager'
import { TokenManager, TMToken } from '/src/components/managers/TokenManager'
import { vi, describe, it, expect, beforeEach } from 'vitest'
import { TokenManager, TMTokenBlock, TMToken } from '/src/components/managers/TokenManager'
import { TokenManager } from '/src/components/managers/TokenManager'
import { vi, describe, it, expect } from 'vitest'
import { TMTokenBlock, TMTokenAggregate } from '/src/components/managers/TokenManager'


// from: test\components\Shared.eligible.spec.ts
(() => {

describe('Shared.eligibleTokens computed', () => {
  it('returns TMTokenAggregate when overlapping blocks exist', () => {
    // Create fake TMTokenBlock-like objects
    const block1 = { start: 0, end: 2, type: 'token-block' }
    const block2 = { start: 3, end: 5, type: 'token-block' }
    // tokenManager with one TMTokenBlock instance
    const tokenManager = {
      tokens: [block1, block2],
      isOverlapping: () => [block1, block2],
    }

    const wrapper = mount(Shared as unknown as Record<string, unknown>, {
      global: { mocks: { $store: { state: { tokenManager, currentPage: 'annotate', tokenManagers: [] }, commit: () => {} }, $q: { dialog: () => ({ onOk: () => {} }) } }, stubs: ['token', 'token-block', 'labels-block', 'aggregate-block', 'info-bar'] },
    })

    const eligible = (wrapper.vm as any).eligibleTokens
    // Should be an array and contain objects (we cannot assert class)
    expect(Array.isArray(eligible)).toBe(true)
  })
})

})();

// from: test\components\SharedSelectTokens.spec.ts
(() => {

describe('Shared.selectTokens behavior', () => {
  it('returns early if no selection', () => {
    const wrapper = mount(Shared as unknown as Record<string, unknown>, { global: { mocks: { $store: { state: { labelManager: { lastId: false }, tokenManagers: [] }, commit: () => {} }, $q: { dialog: vi.fn() } } } })
    // simulate event with detail=1 and no selection
    const fn = (wrapper.vm as unknown as { selectTokens: (e: MouseEvent) => unknown }).selectTokens
    const res = fn({ detail: 1 } as MouseEvent)
    expect(res).toBeUndefined()
  })

  it('shows dialog when no labels available', () => {
    const dialog = vi.fn(() => ({ onOk: () => {} }))
    const wrapper = mount(Shared as unknown as Record<string, unknown>, { global: { mocks: { $store: { state: { labelManager: { lastId: 0 }, tokenManagers: [] }, commit: () => {} }, $q: { dialog } } } })
    const fn = (wrapper.vm as any).selectTokens
    // create a selection-like object on document
  const selectionMock: unknown = { anchorOffset: 1, focusOffset: 2, anchorNode: {}, focusNode: {}, getRangeAt: () => ({ startContainer: { parentElement: { id: 't1' } }, endContainer: { parentElement: { id: 't2' }, endOffset: 2 }, rangeCount: 1 }), rangeCount: 1, empty: () => {} }
  // provide fake selection for test
  // @ts-expect-error override DOM API in test
  document.getSelection = () => selectionMock
  fn({ detail: 1 } as MouseEvent)
    expect(dialog).toHaveBeenCalled()
  })

  it('handles overlapping branch when tokenManager.isOverlapping returns array', () => {
  const dialog = vi.fn(() => ({ onOk: (cb: () => void) => cb() }))
  const isOverlapping = vi.fn(() => [{ start: 0, end: 1 }])
  const addNewBlock = vi.fn()
  const tokenManager = { isOverlapping, addNewBlock }
  const versionControlManager = { addUndo: vi.fn() }
  const wrapper = mount(Shared as unknown as Record<string, unknown>, { global: { mocks: { $store: { state: { labelManager: { lastId: 1, currentLabel: {} }, tokenManagers: [tokenManager], tokenManager, versionControlManager }, commit: () => {} }, $q: { dialog } }, stubs: { 'q-dialog': true } } })
    const selectionMock = { anchorOffset: 1, focusOffset: 2, anchorNode: {}, focusNode: {}, getRangeAt: () => ({ startContainer: { parentElement: { id: 't1' } }, endContainer: { parentElement: { id: 't2' }, endOffset: 2 }, rangeCount: 1 }), rangeCount: 1, empty: () => {} }
  // provide fake selection for test
  // @ts-expect-error override DOM API in test
  document.getSelection = () => selectionMock
  const fn = (wrapper.vm as unknown as { selectTokens: (e: MouseEvent) => unknown }).selectTokens
  fn({ detail: 1 } as MouseEvent)
  expect(isOverlapping).toHaveBeenCalled()
  expect(versionControlManager.addUndo).toHaveBeenCalled()
  })
})

})();

// from: test\shared\eligible_tokens.spec.ts
(() => {

test('eligibleTokens returns aggregate when overlapping blocks present and dedups duplicates', () => {
  const label = new Label(1, 'L', 'red-11')
  // create two overlapping blocks
  const b1 = new TMTokenBlock(0, 3, [TMToken.fromObject([0,1,'a']), TMToken.fromObject([1,2,'b']), TMToken.fromObject([2,3,'c'])], label, 'Candidate')
  const b2 = new TMTokenBlock(1, 4, [TMToken.fromObject([1,2,'b']), TMToken.fromObject([2,3,'c']), TMToken.fromObject([3,4,'d'])], label, 'Candidate')

  const tokenManager = { tokens: [b1, b2], isOverlapping: (s: number, e: number) => [b1, b2] }

  const ctx: any = {
    tokenManager,
    TMToken,
    TMTokenBlock,
    TMTokenAggregate,
  }

  const fn = (Shared as any).computed.eligibleTokens
  const out = fn.call(ctx)
  // Should return a TMTokenAggregate for the overlap
  expect(out.length).toBe(1)
  expect((out[0] as any).type).toBe('token-aggregate')
})

})();

// from: test\shared.spec.ts
(() => {
/* eslint-disable @typescript-eslint/no-explicit-any */

describe('shared.vue', () => {
  let lm: LabelManager
  let tm: TokenManager

  beforeEach(() => {
    lm = new LabelManager()
    // create simple tokens: [t0..t3]
    const tokens = [
      [0, 1, 'a'],
      [1, 2, 'b'],
      [2, 3, 'c'],
      [3, 4, 'd'],
    ] as any
    tm = new TokenManager(lm, tokens)
  })

  it('eligibleTokens returns TMToken instances for simple tokens', () => {
    const store: any = {
      state: { tokenManager: tm, tokenManagers: [tm], currentIndex: 0, labelManager: lm, currentPage: 'annotate', versionControlManager: { addUndo: vi.fn() } },
      commit: vi.fn(),
    }

    const wrapper = mount(Shared as any, {
      global: { mocks: { $store: store, $q: { dialog: vi.fn(), notify: vi.fn(), dark: { isActive: false } } } },
    })

    const list = (wrapper.vm as any).eligibleTokens
    expect(Array.isArray(list)).toBe(true)
    // Should be TMToken instances (not aggregates) since no blocks
    expect(list.length).toBe(4)
    expect(list[0] instanceof TMToken).toBe(true)
  })

  it('selectTokens early returns when selection is collapsed or invalid', async () => {
    const store: any = { state: { tokenManager: tm, tokenManagers: [tm], currentIndex: 0, labelManager: lm, currentPage: 'annotate', versionControlManager: { addUndo: vi.fn() } } }

    const wrapper = mount(Shared as any, {
      global: { mocks: { $store: store, $q: { dialog: vi.fn(), notify: vi.fn(), dark: { isActive: false } } } },
    })

    // Mock selection to simulate collapsed selection
    const node = {}
    const sel = {
      anchorOffset: 0,
      focusOffset: 0,
      anchorNode: node,
      focusNode: node,
      getRangeAt: () => { throw new Error('no range') },
      rangeCount: 0,
      empty: vi.fn(),
    }
  ;(document as any).getSelection = () => sel as unknown as Selection

    // Create a fake event
    const e = { detail: 1 } as unknown as MouseEvent
    await (wrapper.vm as any).selectTokens(e)

    // No changes should be applied; tokens length unchanged
    expect(tm.tokens.length).toBe(4)
  })

  it('selectTokens shows dialog and empties selection when no labels available', async () => {
    const lmNo = new LabelManager()
    // labelManager.lastId === 0 triggers no-tags dialog
    const sel = {
      anchorOffset: 0,
      focusOffset: 1,
      anchorNode: {},
      focusNode: {},
  getRangeAt: () => ({ startContainer: { parentElement: { id: 't0' } }, startOffset: 0, endContainer: { parentElement: { id: 't1' } }, endOffset: 0 }),
      rangeCount: 1,
      empty: vi.fn(),
    }
  ;(document as any).getSelection = () => sel as unknown as Selection

    const dialogMock = vi.fn()

    const store: any = { state: { tokenManager: tm, tokenManagers: [tm], currentIndex: 0, labelManager: lmNo, currentPage: 'annotate', versionControlManager: { addUndo: vi.fn() } } }

    const wrapper = mount(Shared as any, {
      global: { mocks: { $store: store, $q: { dialog: dialogMock, notify: vi.fn(), dark: { isActive: false } } } },
    })

    const e = { detail: 1 } as unknown as MouseEvent
    await (wrapper.vm as any).selectTokens(e)

    expect(dialogMock).toHaveBeenCalled()
    expect(sel.empty).toHaveBeenCalled()
  })

  it('selectTokens handles overlapping branch and calls addUndo and addNewBlock onOk', async () => {
    // prepare label manager with a label
    const lmYes = new LabelManager()
    lmYes.addLabel('X')

    // stub tokenManager.isOverlapping to return an array and spy on addNewBlock
    const tmStub: any = { isOverlapping: vi.fn(() => [{ start: 0, end: 1 }]), addNewBlock: vi.fn() }
    const vcm = { addUndo: vi.fn() }

    const sel = {
      anchorOffset: 0,
      focusOffset: 1,
      anchorNode: {},
      focusNode: {},
  getRangeAt: () => ({ startContainer: { parentElement: { id: 't0' } }, startOffset: 0, endContainer: { parentElement: { id: 't1' } }, endOffset: 0 }),
      rangeCount: 1,
      empty: vi.fn(),
    }
  ;(document as any).getSelection = () => sel as unknown as Selection

    const dialogMock = vi.fn(() => {
      return {
        onOk(cb: any) {
          cb()
          return { onOk() {} }
        },
      }
    })

    const store: any = { state: { tokenManager: tmStub, tokenManagers: [tmStub], currentIndex: 0, labelManager: lmYes, currentPage: 'annotate', versionControlManager: vcm } }

    const wrapper = mount(Shared as any, {
      global: { mocks: { $store: store, $q: { dialog: dialogMock, notify: vi.fn(), dark: { isActive: false } } } },
    })

    const e = { detail: 1 } as unknown as MouseEvent
    await (wrapper.vm as any).selectTokens(e)

    expect(dialogMock).toHaveBeenCalled()
    expect(vcm.addUndo).toHaveBeenCalledWith(tmStub)
    expect(tmStub.addNewBlock).toHaveBeenCalled()
  })
})

})();

// from: test\shared_aggregate.spec.ts
(() => {

describe('shared.vue eligibleTokens aggregate branch', () => {
  it('returns TMTokenAggregate when overlapping blocks present', () => {
    const lm = new LabelManager()
    lm.addLabel('A')
    const tm = new TokenManager(lm, [])
    const b1 = new TMTokenBlock(0,2,[new TMToken(0,1,'a','Candidate')], lm.currentLabel as any, 'Candidate')
    const b2 = new TMTokenBlock(1,3,[new TMToken(1,2,'b','Candidate')], lm.currentLabel as any, 'Candidate')
    tm.tokens = [b1, b2]

    const store: any = { state: { tokenManager: tm, tokenManagers: [tm], currentIndex: 0, labelManager: lm, versionControlManager: { addUndo: () => {} }, currentPage: 'annotate' }, commit: () => {} }
    const wrapper = mount(Shared as any, { global: { mocks: { $store: store, $q: { dialog: () => ({ onOk: () => {} }), notify: () => {}, dark: { isActive: false } } } } })
    const eligible = (wrapper.vm as any).eligibleTokens
    // should include an aggregate
    expect(eligible.some((t: any) => t.type === 'token-aggregate')).toBe(true)
  })
})

})();

// from: test\shared_more.spec.ts
(() => {
/* eslint-disable @typescript-eslint/no-explicit-any */

describe('shared.vue additional branches', () => {
  it('selectTokens non-overlapping calls addUndo and addNewBlock (Suggested on review page)', async () => {
    const lm = new LabelManager()
    lm.addLabel('X')

    const tmStub: any = { isOverlapping: vi.fn(() => null), addNewBlock: vi.fn() }
    const vcm = { addUndo: vi.fn() }

    const sel = {
      anchorOffset: 0,
      focusOffset: 1,
      anchorNode: {},
      focusNode: {},
      getRangeAt: () => ({ startContainer: { parentElement: { id: 't1' } }, startOffset: 0, endContainer: { parentElement: { id: 't2' } }, endOffset: 0 }),
      rangeCount: 1,
      empty: vi.fn(),
    }
    ;(document as any).getSelection = () => sel as unknown as Selection

    const store: any = { state: { tokenManager: tmStub, tokenManagers: [tmStub], currentIndex: 0, labelManager: lm, currentPage: 'review', versionControlManager: vcm }, commit: vi.fn() }

    const wrapper = mount(Shared as any, {
      global: { mocks: { $store: store, $q: { dialog: vi.fn(() => ({ onOk() {} })), notify: vi.fn(), dark: { isActive: false } } } },
    })

    const e = { detail: 1 } as unknown as MouseEvent
    await (wrapper.vm as any).selectTokens(e)

    expect(vcm.addUndo).toHaveBeenCalledWith(tmStub)
    expect(tmStub.addNewBlock).toHaveBeenCalled()
    expect(sel.empty).toHaveBeenCalled()
  })

  it('tokenizeCurrentSentence / tmEdited watch handler executes mapped mutation', () => {
    const lm = new LabelManager()
    const tm = new TokenManager(lm, [[0,1,'a']])

    const store: any = { state: { tokenManager: tm, tokenManagers: [tm], currentIndex: 0, labelManager: lm, currentPage: 'annotate', versionControlManager: { addUndo: vi.fn() } }, commit: vi.fn() }

    const wrapper = mount(Shared as any, {
      global: { mocks: { $store: store, $q: { dialog: vi.fn(), notify: vi.fn(), dark: { isActive: false } } } },
    })

    // Call the watch handler directly to exercise the watch branch
    ;(wrapper.vm as any).$options.watch.tmEdited.handler.call(wrapper.vm)

    // The mapped mutation should call store.commit internally
    expect(store.commit).toHaveBeenCalled()
  })

  it('selectTokens returns early when range parsing throws', async () => {
    const lm = new LabelManager()
    const tokens = [[0,1,'a'],[1,2,'b']] as any
    const tm = new TokenManager(lm, tokens)

    const store: any = { state: { tokenManager: tm, tokenManagers: [tm], currentIndex: 0, labelManager: lm, currentPage: 'annotate', versionControlManager: { addUndo: vi.fn() } }, commit: vi.fn() }

    // Make getRangeAt return an object with null parentElement to force parse failure
    const sel = {
      anchorOffset: 0,
      focusOffset: 1,
      anchorNode: {},
      focusNode: {},
      getRangeAt: () => ({ startContainer: { parentElement: null }, startOffset: 0, endContainer: { parentElement: null }, endOffset: 0 }),
      rangeCount: 1,
      empty: vi.fn(),
    }
    ;(document as any).getSelection = () => sel as unknown as Selection

    const wrapper = mount(Shared as any, {
      global: { mocks: { $store: store, $q: { dialog: vi.fn(), notify: vi.fn(), dark: { isActive: false } } } },
    })

    const e = { detail: 1 } as unknown as MouseEvent
    await (wrapper.vm as any).selectTokens(e)

    // No blocks should be added
    expect(tm.tokens.length).toBe(2)
  })
})

})();

// from: test\shared_more2.spec.ts
(() => {
/* eslint-disable @typescript-eslint/no-explicit-any */

describe('shared.vue remaining branches', () => {
  it('eligibleTokens adds TMTokenBlock when not overlapping', () => {
    // create a fake block instance (provide TMToken for tokens array)
    const t0: any = { start: 0, end: 1, text: 'a', currentState: 'Candidate', type: 'token' }
    const block = new TMTokenBlock(0, 2, [t0], { id: 'l1', name: 'L', color: '#000' }, 'Candidate')

    const tmStub: any = { tokens: [block], isOverlapping: vi.fn(() => null) }
    const store: any = { state: { tokenManager: tmStub, tokenManagers: [tmStub], currentIndex: 0, labelManager: { lastId: 1 }, currentPage: 'annotate', versionControlManager: { addUndo: vi.fn() } }, commit: vi.fn() }

    const wrapper = mount(Shared as any, { global: { mocks: { $store: store, $q: { dialog: vi.fn(), notify: vi.fn(), dark: { isActive: false } } } } })

    const list = (wrapper.vm as any).eligibleTokens
    expect(list.length).toBe(1)
    expect(list[0]).toBe(block)
  })

  it('eligibleTokens deduplicates overlapping aggregates', () => {
    // create two blocks that would produce the same aggregate
  const t1: any = { start: 0, end: 1, text: 'a', currentState: 'Candidate', type: 'token' }
  const t2: any = { start: 1, end: 2, text: 'b', currentState: 'Candidate', type: 'token' }
  const b1 = new TMTokenBlock(0, 2, [t1], { id: 'l1', name: 'L', color: '#000' }, 'Candidate')
  const b2 = new TMTokenBlock(1, 3, [t2], { id: 'l1', name: 'L', color: '#000' }, 'Candidate')

    // overlapping array returned for both calls - same serialized overlap
    const overlapping = [b1, b2]
    const tmStub: any = { tokens: [b1, b2], isOverlapping: vi.fn(() => overlapping) }
    const store: any = { state: { tokenManager: tmStub, tokenManagers: [tmStub], currentIndex: 0, labelManager: { lastId: 1 }, currentPage: 'annotate', versionControlManager: { addUndo: vi.fn() } }, commit: vi.fn() }

    const wrapper = mount(Shared as any, { global: { mocks: { $store: store, $q: { dialog: vi.fn(), notify: vi.fn(), dark: { isActive: false } } } } })

    const list = (wrapper.vm as any).eligibleTokens
    // Should produce a single aggregate, not duplicate
    expect(list.length).toBe(1)
    expect(list[0] instanceof TMTokenAggregate).toBe(true)
  })

  it('onRemoveBlock calls addUndo and removeBlock', () => {
    const removeSpy = vi.fn()
    const tmStub: any = { removeBlock: removeSpy }
    const vcm = { addUndo: vi.fn() }
    const store: any = { state: { tokenManager: tmStub, tokenManagers: [tmStub], currentIndex: 0, labelManager: { lastId: 1 }, currentPage: 'annotate', versionControlManager: vcm }, commit: vi.fn() }

    const wrapper = mount(Shared as any, { global: { mocks: { $store: store, $q: { dialog: vi.fn(), notify: vi.fn(), dark: { isActive: false } } } } })

    ;(wrapper.vm as any).onRemoveBlock(42)
    expect(vcm.addUndo).toHaveBeenCalledWith(tmStub)
    expect(removeSpy).toHaveBeenCalledWith(42)
  })

  it('beforeLeave returns warning string', () => {
    const wrapper = mount(Shared as any, { global: { mocks: { $store: { state: {} } } } })
    const res = (wrapper.vm as any).beforeLeave()
    expect(typeof res).toBe('string')
    expect(res.length).toBeGreaterThan(0)
  })
})

})();

// from: test\shared_more3.spec.ts
(() => {
/* eslint-disable @typescript-eslint/no-explicit-any */

describe('shared.vue extra branches', () => {
  it('selectTokens returns early on double click (e.detail>1)', async () => {
    const lm = new LabelManager()
    const tmStub: any = { tokens: [], isOverlapping: vi.fn(() => null), addNewBlock: vi.fn() }
    const store: any = { state: { tokenManager: tmStub, tokenManagers: [tmStub], currentIndex: 0, labelManager: lm, currentPage: 'annotate', versionControlManager: { addUndo: vi.fn() } }, commit: vi.fn() }

    const wrapper = mount(Shared as any, { global: { mocks: { $store: store, $q: { dialog: vi.fn(), notify: vi.fn(), dark: { isActive: false } } } } })

    const sel = { anchorOffset: 0, focusOffset: 1, anchorNode: {}, focusNode: {}, getRangeAt: () => ({ startContainer: { parentElement: { id: 't0' } }, startOffset: 0, endContainer: { parentElement: { id: 't1' } }, endOffset: 0 }), rangeCount: 1, empty: vi.fn() }
    ;(document as any).getSelection = () => sel as unknown as Selection

    const e = { detail: 2 } as unknown as MouseEvent
    await (wrapper.vm as any).selectTokens(e)

    // Should not have attempted to add a block
    expect(store.state.versionControlManager.addUndo).not.toHaveBeenCalled()
  })

  it('selectTokens overlapping dialog cancel path does not call addUndo or addNewBlock', async () => {
    const lm = new LabelManager()
    lm.addLabel('X')
    const tmStub: any = { isOverlapping: vi.fn(() => [{ start: 0, end: 1 }]), addNewBlock: vi.fn() }
    const vcm = { addUndo: vi.fn() }

    const sel = { anchorOffset: 0, focusOffset: 1, anchorNode: {}, focusNode: {}, getRangeAt: () => ({ startContainer: { parentElement: { id: 't0' } }, startOffset: 0, endContainer: { parentElement: { id: 't1' } }, endOffset: 0 }), rangeCount: 1, empty: vi.fn() }
    ;(document as any).getSelection = () => sel as unknown as Selection

    // dialog mock that returns an object without calling onOk (simulate cancel)
    const dialogMock = vi.fn(() => ({ onOk() { /* no call */ } }))

    const store: any = { state: { tokenManager: tmStub, tokenManagers: [tmStub], currentIndex: 0, labelManager: lm, currentPage: 'annotate', versionControlManager: vcm }, commit: vi.fn() }

    const wrapper = mount(Shared as any, { global: { mocks: { $store: store, $q: { dialog: dialogMock, notify: vi.fn(), dark: { isActive: false } } } } })

    const e = { detail: 1 } as unknown as MouseEvent
    await (wrapper.vm as any).selectTokens(e)

    expect(vcm.addUndo).not.toHaveBeenCalled()
    expect(tmStub.addNewBlock).not.toHaveBeenCalled()
  })

  it('tokenizeCurrentSentence calls the mapped mutation setTokenManager via commit', () => {
    const lm = new LabelManager()
    const tm = { tokens: [] }
    const store: any = { state: { tokenManagers: [tm], currentIndex: 0 }, commit: vi.fn() }
    const wrapper = mount(Shared as any, { global: { mocks: { $store: store, $q: { dialog: vi.fn(), notify: vi.fn(), dark: { isActive: false } } } } })

    ;(wrapper.vm as any).tokenizeCurrentSentence()

    expect(store.commit).toHaveBeenCalled()
  })
})

})();

