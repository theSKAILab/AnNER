// AUTO-GENERATED by scripts/consolidate-tests.js
// Consolidated tests for source: App

import { describe, it, expect, vi } from 'vitest'
// Mock Quasar's useQuasar before importing the component so setup() picks it up
const notifyMock = vi.fn()
vi.mock('quasar', () => ({ useQuasar: () => ({ notify: notifyMock }) }))

import { mount, shallowMount } from '@vue/test-utils'
import App from '/src/App.vue'
import { store } from '/src/components/managers/Store'
import MenuBar from '/src/components/toolbars/MenuBar.vue'
import LabelsBlock from '/src/components/blocks/LabelsBlock.vue'
import TokenBlock from '/src/components/blocks/TokenBlock.vue'


// from: test\app\app_dragdrop.spec.ts
(() => {

describe('App drag and drop handlers', () => {
  it('toggles overlayActive on drag enter/leave when currentPage is start', async () => {
    store.state.currentPage = 'start'
    const wrapper = mount(App as any, { global: { mocks: { $store: store, $q: { dark: { isActive: false } } } } })
    const vm: any = wrapper.vm
    // overlay should initially be false
    expect(vm.overlayActive).toBe(false)
    vm.onDragEnter()
    expect(vm.overlayActive).toBe(true)
    vm.onDragLeave()
    expect(vm.overlayActive).toBe(false)
  })

  it('onDrop sets pendingFileDrop and calls loadFile when on start', async () => {
    store.state.currentPage = 'start'
    const wrapper = mount(App as any, { global: { mocks: { $store: store, $q: { dark: { isActive: false } } } } })
    const vm: any = wrapper.vm
  const fakeFile = new File(['hello'], 'f.txt', { type: 'text/plain' })
    const event = { dataTransfer: { files: [fakeFile] } }
    vm.onDrop(event as any)
    expect(vm.pendingFileDrop).toBe(fakeFile)
  })
})

})();

// from: test\App.spec.ts
(() => {

// (App.spec.ts original block) Note: quasar mock is declared above so setup() picks it up
describe('App.vue drag/drop behavior', () => {
  it('toggles overlayActive on drag enter/leave and handles drop', async () => {
    const loadFile = vi.fn()
    const wrapper = mount(App as any, {
      global: {
        mocks: {
          $store: { state: { currentPage: 'start' }, commit: () => {}, dispatch: () => {}, loadFile },
          $q: { notify: vi.fn() },
        },
        stubs: ['menu-bar', 'start-page', 'annotation-page', 'review-page', 'exit-dialog'],
      },
    })

    // Initially overlay inactive
    expect((wrapper.vm as any).overlayActive).toBe(false)

    // Drag enter should set overlayActive when on start page
    await wrapper.trigger('dragenter')
    expect((wrapper.vm as any).overlayActive).toBe(true)

    // Drag leave should clear it
    await wrapper.trigger('dragleave')
    expect((wrapper.vm as any).overlayActive).toBe(false)

    // Simulate drop with a fake file
    const file = new File(['content'], 'test.txt', { type: 'text/plain' })
    const dataTransfer = { files: [file] }
    await wrapper.trigger('drop', { dataTransfer })
    // pendingFileDrop should be set to file
    expect((wrapper.vm as any).pendingFileDrop).toBe(file)
  })

  it('notify setup calls Quasar.notify with expected payload', () => {
    const loadFile = vi.fn()
    const wrapper = mount(App as any, {
      global: {
        mocks: {
          $store: { state: { currentPage: 'start' }, commit: () => {}, dispatch: () => {}, loadFile },
          $q: { notify: vi.fn() },
        },
        stubs: ['menu-bar', 'start-page', 'annotation-page', 'review-page', 'exit-dialog'],
      },
    })

    // call the notify wrapper returned by setup()
    ;(wrapper.vm as any).notify('i', 'hello', 'blue')

    expect(notifyMock).toHaveBeenCalled()
    expect(notifyMock).toHaveBeenCalledWith(expect.objectContaining({ icon: 'i', message: 'hello', color: 'blue' }))
  })

  it('drop when not on start page sets pendingFileDrop but does not call loadFile and shows exit-dialog', async () => {
    const loadFile = vi.fn()
    const wrapper = mount(App as any, {
      global: {
        mocks: {
          $store: { state: { currentPage: 'annotate' }, commit: () => {}, dispatch: () => {}, loadFile },
          $q: { notify: vi.fn() },
        },
        stubs: ['menu-bar', 'start-page', 'annotation-page', 'review-page', 'exit-dialog'],
      },
    })

    const file = new File(['content'], 'other.txt', { type: 'text/plain' })
    const dataTransfer = { files: [file] }
    await wrapper.trigger('drop', { dataTransfer })

    // loadFile should not have been called because currentPage != 'start'
    expect(loadFile).not.toHaveBeenCalled()

    // exit-dialog stub should receive show=true since pendingFileDrop != null and currentPage != 'start'
    const exitStub = wrapper.find('exit-dialog-stub')
    expect(exitStub.exists()).toBe(true)
    expect(exitStub.attributes('show')).toBe('true')
  })
})

})();

// from: test\components\App.methods.spec.ts
(() => {

describe('App methods (direct)', () => {
  it('onDragEnter sets overlayActive only when on start page', () => {
    const ctx: any = { currentPage: 'start', overlayActive: false }
    ;(App.methods as any).onDragEnter.call(ctx)
    expect(ctx.overlayActive).toBe(true)

    const ctx2: any = { currentPage: 'annotate', overlayActive: false }
    ;(App.methods as any).onDragEnter.call(ctx2)
    expect(ctx2.overlayActive).toBe(false)
  })

  it('onDragLeave clears overlayActive only on start page', () => {
    const ctx: any = { currentPage: 'start', overlayActive: true }
    ;(App.methods as any).onDragLeave.call(ctx)
    expect(ctx.overlayActive).toBe(false)
  })

  it('onDrop sets pendingFileDrop and calls loadFile when on start', () => {
    const file = { name: 'f' }
    const ctx: any = { currentPage: 'start', overlayActive: true, pendingFileDrop: null, loadFile: vi.fn() }
    const ev: any = { dataTransfer: { files: [file] } }
    ;(App.methods as any).onDrop.call(ctx, ev)
    expect(ctx.pendingFileDrop).toBe(file)
    expect(ctx.loadFile).toHaveBeenCalledWith(file)
    expect(ctx.overlayActive).toBe(false)
  })
})

})();

// from: test\coverage_funcs_additional.spec.ts
(() => {

// Test App.setup which uses useQuasar - mock it so setup runs safely

describe('coverage targeted functions', () => {
  it('App.setup returns notify and it can be called', () => {
    const setupReturn = (App as any).setup()
    expect(typeof setupReturn.notify).toBe('function')
    // call notify to execute inner function body
    setupReturn.notify('icon', 'message', 'positive')
  })

  it('MenuBar.created adds document and window event listeners', () => {
    const docSpy = vi.spyOn(document, 'addEventListener')
    const winSpy = vi.spyOn(window, 'addEventListener')

    const ctx: any = { menuKeyBind: vi.fn() }
    ;(MenuBar as any).created.call(ctx)

    expect(docSpy).toHaveBeenCalled()
    // should have registered keyup on document
    expect(docSpy).toHaveBeenCalledWith('keyup', ctx.menuKeyBind)
    // should have registered beforeinstallprompt and appinstalled on window
    expect(winSpy).toHaveBeenCalled()

    docSpy.mockRestore()
    winSpy.mockRestore()
  })

  it('LabelsBlock watcher allLabels can be invoked directly', () => {
    const labelManager = { allLabels: [], currentLabel: { id: 1, name: 'A', color: 'red-11' } }
    const wrapper = shallowMount(LabelsBlock, {
      global: { mocks: { $store: { state: { labelManager } }, $q: { dark: { isActive: false }, notify: vi.fn(), dialog: vi.fn() } }, stubs: ['q-chip', 'q-avatar', 'q-input', 'q-btn', 'q-card-section', 'q-space'] },
    })

    // call the watcher function directly from the component options
    ;(LabelsBlock as any).watch.allLabels.call((wrapper.vm as any))
  })

  it('TokenBlock.toggleReviewed calls restoreOriginalBlockState when reviewed', () => {
    const token = { start: 5, reviewed: true, currentState: 'Candidate', labelClass: { color: 'red-11', name: 'A' }, tokens: [] }
    const tokenManager = { restoreOriginalBlockState: vi.fn() }
    const versionControlManager = { addUndo: vi.fn() }

    const wrapper = shallowMount(TokenBlock as any, {
      props: { token },
      global: {
        mocks: {
          $store: { state: { currentPage: 'review', tokenManager, versionControlManager } },
        },
        stubs: ['q-btn', 'Token'],
      },
    })

    const vm: any = wrapper.vm
    ;(vm as any).toggleReviewed()
    expect(tokenManager.restoreOriginalBlockState).toHaveBeenCalledWith(token.start)
  })
})

})();

